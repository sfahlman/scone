;;; Performance benchmark baseline test for adding all knowledge that can be
;;; inferred from rules without using rules in the setting of family tree structure.
;;; To use this, load this kb WITHOUT loading core.lisp, then use the
;;; test-parents-manual function to test performance.

(new-type {person} {thing})
(new-complete-split-subtypes {person} '({male} {female}))
(new-type-role {parent} {person} {person} :n 2)
(new-indv-role {mother} {person} {parent})
(new-is-a {mother} {female})
(new-indv-role {father} {person} {parent})
(new-is-a {father} {male})
(new-type-role {child} {person} {person} :may-have t)
(new-indv-role {daughter} {person} {child} :may-have t)
(new-is-a {daughter} {female})
(new-indv-role {son} {person} {child} :may-have t)
(new-is-a {son} {male})
(new-indv-role {spouse} {person} {person} :may-have t)
(new-indv-role {wife} {person} {spouse} :may-have t)
(new-is-a {wife} {female})
(new-indv-role {husband} {person} {spouse} :may-have t)
(new-is-a {husband} {male})
(new-type-role {sibling} {person} {person} :may-have t)
(new-type-role {sister} {person} {sibling} :may-have t)
(new-is-a {sister} {female})
(new-type-role {brother} {person} {sibling} :may-have t)
(new-is-a {brother} {male})
(new-type-role {grandparent} {person} {person} :n 4)
(new-type-role {grandfather} {person} {grandparent} :n 2)
(new-is-a {grandfather} {male})
(new-type-role {grandmother} {person} {grandparent} :n 2)
(new-is-a {grandmother} {female})
(new-type-role {grandchild} {person} {person} :may-have t)
(new-type-role {grandson} {person} {grandchild} :may-have t)
(new-is-a {grandson} {male})
(new-type-role {granddaughter} {person} {grandchild} :may-have t)
(new-is-a {granddaughter} {female})
(new-type-role {uncle} {person} {male} :may-have t)
(new-type-role {aunt} {person} {female} :may-have t)
(new-type-role {cousin} {person} {person} :may-have t)
(new-type-role {nephew} {person} {male} :may-have t)
(new-type-role {niece} {person} {female} :may-have t)

(defun test-parents-manual (npeople)
  "Create npeople {person} nodes where each one is {male} and the {parent} of the previous node,
   and add all family relationships we can infer from this (father, son, grandfather, etc.)"
  (dotimes (number npeople)
    (commentary "~D" number)
    (let ((node
            (new-indv (make-element-iname :value (format nil "mperson ~D" number)) {person})))
      (new-is-a node {male})
      (when (>= number 1)
        (let ((prev (lookup-element (format nil "mperson ~D" (1- number)))))
          (x-is-a-y-of-z node {parent} prev)
          (x-is-a-y-of-z prev {child} node)
          (x-is-a-y-of-z node {father} prev)
          (x-is-a-y-of-z prev {son} node)))
      (when (>= number 2)
        (let ((prev2 (lookup-element (format nil "mperson ~D" (- number 2)))))
          (x-is-a-y-of-z node {grandparent} prev2)
          (x-is-a-y-of-z prev2 {grandchild} node)
          (x-is-a-y-of-z node {grandfather} prev2)
          (x-is-a-y-of-z prev2 {grandson} node))))))

